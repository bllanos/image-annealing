//! # Example data synthesis executable
//!
//! Input data generation executable for the 'dot' example

use image_annealing::compute::format::ImageFileWriter;
use image_annealing::ImageDimensions;
use std::error::Error;
use std::path::PathBuf;

mod synthesis;

/// Parse command-line arguments
///
/// A single number representing the side length of a square image
/// is expected as an argument (aside from the first argument
/// containing the program's name).
///
/// # Panics
///
/// Panics if `args` has no items
///
/// # Errors
///
/// Returns an error if the command-line argument cannot be
/// parsed into a valid image width/height
fn parse_args<T>(args: T) -> Result<ImageDimensions, Box<dyn Error>>
where
    T: IntoIterator<Item = String>,
{
    let mut args_iter = args.into_iter();
    args_iter
        .next()
        .expect("no arguments (not even the program name)");
    let image_width: usize = args_iter
        .next()
        .ok_or("expected a square image side length as a command-line argument")?
        .parse()?;
    Ok(ImageDimensions::try_new(image_width, image_width)?)
}

/// Generate input data for the example
///
/// The following image files are generated:
/// - An image generated by [synthesis::white_dot]
/// - An displacement goal generated by [synthesis::dot_goal]
///
/// Both image files have square dimensions, with widths and heights given
/// by a command-line argument.
///
/// Files are saved to `examples_output/image_annealing_cli_bin_dot`
///
/// # Examples
///
/// Generate images of dimension `25 x 25` pixels:
/// ```
/// cargo run -p image_annealing_cli_bin --release --example dot -- 25
/// ```
fn main() -> Result<(), Box<dyn Error>> {
    let dimensions = parse_args(std::env::args())?;
    println!("Generating data using image dimensions {}", dimensions);

    let mut image_path_no_extension = PathBuf::new();
    image_path_no_extension
        .extend(["examples_output", "image_annealing_cli_bin_dot", "image"].into_iter());
    let image_path =
        synthesis::white_dot(&dimensions).save_add_extension(image_path_no_extension)?;
    println!("Saved input image to {}", image_path.display());

    let mut displacement_goal_path_no_extension = PathBuf::new();
    displacement_goal_path_no_extension.extend(
        [
            "examples_output",
            "image_annealing_cli_bin_dot",
            "displacement_goal",
        ]
        .into_iter(),
    );
    let displacement_goal_path =
        synthesis::dot_goal(&dimensions).save_add_extension(displacement_goal_path_no_extension)?;
    println!(
        "Saved input displacement goal to {}",
        displacement_goal_path.display()
    );
    Ok(())
}

#[cfg(test)]
mod tests {
    mod parse_args {
        use super::super::parse_args;
        use image_annealing::ImageDimensions;
        use std::error::Error;

        #[test]
        #[should_panic(expected = "no arguments (not even the program name)")]
        fn empty_input() {
            let v: Vec<String> = Vec::new();
            let _ = parse_args(v);
        }

        #[test]
        fn no_argument() {
            let v = vec![String::from("12")];
            test_utils::assert_error_contains(
                parse_args(v),
                "expected a square image side length as a command-line argument",
            );
        }

        #[test]
        fn negative() {
            let v = vec![String::from("12"), String::from("-1")];
            test_utils::assert_error_contains(parse_args(v), "invalid digit found in string");
        }

        #[test]
        fn fraction() {
            let v = vec![String::from("12"), String::from("1.5")];
            test_utils::assert_error_contains(parse_args(v), "invalid digit found in string");
        }

        #[test]
        fn zero() {
            let v = vec![String::from("12"), String::from("0")];
            test_utils::assert_error_contains(parse_args(v), "width is zero");
        }

        #[test]
        fn success() -> Result<(), Box<dyn Error>> {
            let v = vec![String::from("12"), String::from("325")];
            assert_eq!(parse_args(v)?, ImageDimensions::try_new(325, 325)?,);
            Ok(())
        }
    }
}
